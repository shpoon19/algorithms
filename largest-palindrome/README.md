#### Problem: Given a string, find the longest palindrome substring

Call the given string s. The brute force solution would have starting and ending indices i and j, and for each such pair check if the substring s[i:j] is a palindrome (what is the complexity of the brute force solution?)

The main insight for solving the problem efficiently is finding substructure. The most apparent substructure is that if we have any palindrome of of length 3 or more from i to j, then the substring from i+1 to j-1 is also a palindrome (removing the first and last elements gives a palindrome). The main idea would be to exploit this so that we don’t have to check if any possible substring from i to j is a palindrome, since we would be making many of the same checks multiple times. To do this efficiently, we can structure our solution as a ‘dynamic program’. This means we remember if for certain pairs i,j the substring s[i:j] is a palindrome, to avoid making the same comparisons multiple times.

For a dynamic programming problem, we need to find the ‘boundaries’, or base cases. In the case of palindromes, this means looking at substrings of length 1 or 2. All substrings of length 1 are automatically palindromes, and it’s easy to to for each substring of length 2. Next, we can start using the substructure property we observed, as we look at longer substrings. For substrings of length 3, we just have to check the first and last indices (since the ‘center’ substring of length 1 is always a palindrome). For substrings of length 4, we can look at all substrings of length 2 that are palindromes, and just check the first and last character, and so on. An efficient implementation may keep a dictionary from a given length of a palindrome to a list of tuples, each representing the first and last characters of a given palindrome. After adding the palindromes of length 1 or 2, we introduce an index k starting from 3 and ending at the length of the string, representing the length of the new palindromes to be found. Given a value of k, we look at all known palindromes of length k-2. We want to see if we can add a new start and end characters, so we also need to make sure each palindrome of length k-2 is not at the beginning or the end. Once this condition is met, we just need to check if the proposed starting and ending value of the new proposed palindrome of length k are equal. The remaining required character equalities are already guaranteed because the inner substring of length k-2 is known to be a palindrome.

This is a good example of dynamic programming: Once we have a known brute force solution, we notice some calculations or comparisons are done multiple times, and can be avoided using substructure in the problem.
